



![[DEC-HEX-BIN.png]]


### HEX DIGITS

1 Hexadecimal Digit = 4 bits

1 Byte = 8 bits = 2 Hex Digits

Range of 1 Unsigned Byte = [0, 255] or 0x00 to 0xFF

We know that each memory address can store only one byte, but what if my number is more than a byte long?

Eg:
```c
// C CODE
int a = 5;
```

While 5 can easily be represented in 1 byte, in C an int is 4 bytes long, so how should these be 4 bytes be arranged in memory?
### Endianness

Endianness refers to how multi-byte data is stored in memory.

A character is each one byte, so it is simply put as is at its address

Eg:
```c
char c = 'a'; // LET c be at address 0x400 then
// ASCII VALUE OF 'a' = 97 = 0x61
```

![[Endian Example.png]]



But what about:
```c
int a = 10; // LET a be at address 0x400 again
```

There are 2 ways:
#### Little Endian:

Meaning little-end of the number should be put first (i.e, at lower address)

#### Big Endian:
Meaning the big-end of the number should be put first.


![[Endian Exaple 2.png]]

Above picture is one of the many logical views of the memory.
Similarly, there are many logical views of CPU registers, therefore always remember.

***In Little-Endian, the logically/mathematically low/less significant byte, goes to the logically/mathematically low/less significant spot, whether it be memory or CPU registers, similar thing in Big-Endian***


Network Order is always Big-Endian

**Any data store and fetch which happens in Intel chips is Little-Endian**






### NEGATIVE NUMBERS IN COMPUTERS


The CPU inherently, electronically does not have the concept of a Negative numbers,

Simply speaking, each byte is an arrangement of 1s and 0s, how that arrangement of 1s and 0s is interpreted is upto the context,

Eg: in C:

```c
uint8_t ui_num = 253; // 1 Byte which stores 253 = 0xFD
int8_t i_nim = -3; // 1 Byte which stores -3 = 0xFD
```

i.e, both these bytes `ui_num` and `i_num` have the same arrangement `11111101`, only under the context that `i_num` is signed will you be able to tell that it is -3, CPUs don't have this context.

NOTE: always just represent every byte in CPU and memory in its full unsigned range, i.e, 0x00 to 0xFF

Deal with signs later,


NOTES TO SELF:
Signed Numbers are always stored in 2's complement forn.
What is 2's complement form you might ask?

Eg: Consider the number decimal 3, its binary representation is 00000011b
To represent the number decimal -3 in binary, we can't simply do -00000011b

So we take 2's complement of bin representation of 3 to get -3



###### 2's Complement:

1. Take 1's complement ==== Flip all the bits to be opposite, i.e, 1's becomr 0, and 0s become 1
2. Add 1 to this 1's complement, now you got the 2's complement


****IF**** dealing with negative numbers, note that the most significant bit (MSB) of a negative number is always 1, and of a positive number is always 0.

