
The C language has minimal restrictions on Data Types and their sizes

According to the C Standard

For integral Data Types
1. ```char```: is 1 Byte
2. ```short```: is at least 2 Bytes
3. ```int```: is at least 2 Bytes
4. ```long```: is at least 4 Bytes
5. ```long long```: is at least 8 Bytes 

For Floating Point Data Types
1. `float`: is at least 4 Bytes
2. `double`: at least 8 Bytes
3. `long double`: at least as large as `double`


BUT IN PRACTICE IT IS COMPILER DEPENDENT

ON THE **64 BIT GCC COMPILER** THE SIZES ARE:
`char`: 1 Byte
`short`: 2 Bytes
`int`: 4 Bytes
`long`: 4 Bytes
`long long`: 8 Bytes
`float`: 4 Bytes
`double`: 8 Bytes
`double long / long double`: 16 Bytes


#### Pointer's Size
Irrespective of the data type of the pointer, the size of a pointer is always the size of the addresses that can be generated/understood by the physical architecture/processor

Therefore on 32 Bit machines, size of pointers = 32 Bits = 4 Bytes
On 64 Bit machines, size of pointers = 64 Bits = 8 Bytes


![[Intel Describing C data types.png]]

Above picture is from the [Nov 2020 Intel Manual](https://ost2images.s3.amazonaws.com/PDFs/325462-sdm-vol-1-2abcd-3abcd.pdf)
Here it is evident that the Windows API uses names for Data types similar to how logic dictates

1 Byte = 8 Bits
1 Word = 2 Bytes = 16 Bits
1 Double Word / `DWORD`  = 2 Words = 4 Bytes = 32 Bits
1 Quad Word / `QWORD`  = 4 Words = 8 Bytes = 64 Bits