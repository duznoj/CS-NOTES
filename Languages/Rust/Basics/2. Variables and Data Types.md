
### 2.1 Declaring and Initializing variables
- Syntax to declare a variable:
```rust
let <var_name> = <some value>;
```

- `let` is the keyword to declare a variable
- By default variables are "immutable", i.e, the `<var_name>` refers to a memory location which cannot be modified, i.e the variable acts as a constant
```rust
let x = 5;
x = 4; // INVALID
```

To make a variable "mutable", the `mut` keyword has to be used.
```rust
let mut x = 5;
x = 6; // VALID
```

### 2.2 Type Inference
- Rust is a statically typed language, but it is not necessary to write the data type of a variable every time.
- If a variable is (declared + initialized), the compiler automatically detects/infers the data type from the data type of the value assigned to it, but later on value of a different type cannot be assigned to the same variable.
```rust
let x = 34; // x: i32
let y = 35.0; // x: f64
```

- For more readability, the type can also be annotated by us
```rust
let mut x: i32 = 69;
```

- It is not valid to only declare a variable without giving it a type, it has to be given a type at least once in the entire file
```rust
let x; // INVALID
```

```rust
let x: i32; // VALID
```

```rust
let x;
...
...
...
x = 69; // VALID
```

- A variable which is not used after initialization will give an "unused variable" warning.
- To suppress it, prefix the variable name with an underscore when declaring it
```rust
let _x: i64 = 420; // VALID
let _y: i32; // VALID

let _z: i32;
z = 69; // INVALID

let a: i32;
_a = 69; // INVALID
```


- A variable name, which is already declared/initialized, can be re-declares using the `let` keyword, this will completely overwrite any old values of that variable, and can also change the type of the variable
```rust
let x = 69;
// SOME LINES OF CODE....
let x = "yo mama";
```

### 2.3 Printing variables
`{}` are used as placeholders inside a format string, now there are 2 ways to use format strings
1. To print the exact value of a variable, put the variable name inside the `{}`
```rust
let x = 69;
println!("value of x is {x}");
```

2. But you can't directly write any arbitrary inside of `{}`
```rust
let x = 34;
println!("Expression is: {x + 35}"); // INVALID
```
- To print out the result of an expression, put empty placeholder in string, and write expression in variadic c-printf style
```rust
println!("First expression {}, second is: {}", 34+35, 20); // VALID
```

### 2.4 Data Types

There are 2 main types of Primitive Data Types in Rust.
1. Scalar: These are single primitive values which are stored on the stack
2. Compound types: These are also primitives, and store a collection of values of any type on the stack


#### 2.4.1 Scalar Types

Rust has 4 main types of scalars.
1. Integers
2. Floating-Point Numbers
3. Booleans
4. Characters

##### 2.4.1.1 Integers
- Can be signed or unsigned
- Can be of different sizes, size-chart and the corresponding data-type names are given below.
- `i32` is the default type for integer literals
- `isize` and `usize` are architecture dependent, i.e, on 32-bit systems they are of 32-bits, on 64-bit systems they are of 64-bits.
![[Integer Data Types.png]]

- Integer Literals can be written in many forms
- The `_` in decimal is optional to write, it's provided for easier reading of large numbers
![[Rust Integer Literals.png]]


##### 2.4.1.2 Floating-Point numbers

- Floating-point numbers are represented according to the IEEE-754 standard.
- There are only 2 Floating-Point types: `f32` and `f64`, and `f64` is default for floating-point literals

##### 2.4.1.3 Booleans

- Are 1 Byte values 
- Data Type is given by the keyword `bool`
- Has only 2 possible values/literals: `true`, `false`

##### 2.4.1.4 Characters

- Rust has `char` as it's character primitive
- It can store 1 single character.
- Character literals are written in single quotes `'a'`
- One `char` is of 4 Bytes, and stores Unicode Code Points


#### 2.4.2 Compound Types

- These are types which hold multiple values.
- They are stored on the stack itself.
- They are of 2 types:
1. Tuples
2. Arrays

##### 2.4.2.1 Tuples

- Tuples are a collection of heterogeneous elements, elements can be of any type, i.e, scalars, or complex structs, etc
- Once created, 

Syntax is:
```rust
let x: (<data types>) = (<values>);
```

- Tuples can be indexed using: `tuple_name.index`
```rust
let x = (69, 420.69, "yomama");
println!("Tuple Elements are: {}, {}, {}", x.0, x.1, x.2);
```

- Tuples can be nested inside tuples, and indexing will also follow:
```rust
tuple_name.outerIndex.innerIndex
```

- Index cannot be given using another variable

```rust
let x = (69, 420.69. "sheeesh");
let y = 1;
println!("{}", x.y); // INVALID
```

- Tuples can be de-structured using:
```rust
let x = (69, 420.69. "sheeesh");
let (a, b, c) = x; // Tuple x is destructured into variables a, b, and c

let (y, z) = x; // INVALID, all elements should be destructured into a variable
```

##### 2.4.2.2 Arrays

- Collection of homogeneous elements, elements can be of any type.
- These are fixed size arrays created on the stack, size must be known at compile time
- Declaration and initialization syntaxes
```rust
let <array_name>: [<data_type> ; <count>] = [<comma separated list of elements>];
let <array_name>: [<data_type> ; <count>] = [<value>; <count>];
```

```rust
let x = [1, 2, 3, 4]; // Declared and initializaed an array of 4 i32s
let y: [f32; 10]; // Declared an array of 10 f32s

// Special initialization
let z = [10; 512]; // Declared and initialized an array, which has 512 elements, each element is 10

// Partial Special Initialization (or) Mixed Special Initializations are also not valid
let a: [i32; 10] = [69, 0;9]; // INVALID

// Complete array re-initialization is valid
let b = [10;5]; // b == [10, 10, 10, 10, 10]
b = [1, 2, 3, 4, 5]; // VALID
```

- Arrays cannot be partially initialized, you have to completely initialize them.
```rust
let x: [f32; 5] = [1.0, 2.5]; // INVALID
let y: [u8; 512];
y = [10; 512]; 
```

- Individual array members can be accessed (read) only after complete initialization at least once.
- Array members can be written to only if array is mutable and at least once completely initialized.



### 2.5 The Unit Type: `()`

- The "unit type" is just an empty tuple.
- It is like `void` in C.
- Size of an object of "unit type" is `0`
- When a function doesn't return anything, it implicitly returns the "unit type".