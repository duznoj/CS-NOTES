
### 3.1 Block of Code, Statements, Expressions and returns

- Any code enclosed withing `{}` is a block of code.
- A statement performs an action but does not return a value.`
	- A statement ends with a semicolon `;`
	- Not returning a value == returning a unit type.
	
- An expression is an action which returns a value for a block of code.
	- It HAS to be the last action inside the block of code.
	- The final action whose value the block of code returns, should NOT end with a semicolon `;`
```rust
let x = {let y = 10;} // let is statement, not an expression, x is now a unit type
let z = {
	let a = 10;
	a*a // Returning expression for this block of code
};
```


- The `return` keyword makes a return STATEMENT,
- It used used to terminate the execution of the called function early, and optionally return a value to the calling function.
- The return statement can return value from any expression
```rust
fn main() {
	println!("{:?}", func());
}

fn func() -> i32 {
	let a = 100;
	return {
		let y = 10;
		a+y
	}
} // Return statement gets a value of 110 from the expression, and returns that to main
```



### 3.2 Functions
- A function in rust are nothing but a named block of code
- The `fn` keyword is used to declare/define a function
- A called function may be declared and defined before or after the calling function, it doesn't matter in rust, unlike C where we had to at least declare it before calling it.
	- All that matters is that the called function is defined in a scope where it's accessible to the calling function, before or after doesn't matter

- Syntax for writing functions:
```rust
fn <function_name>(<parameter_list>) -> <return_type> {
	// body of the function
}
```

- The parameter list has to be type annotated, and return type should be given if function returns a value, if not then `-> <return_type>` can be omitted and function will return a unit type.

```rust
fn main() {
	my_func(10, 20);
}

fn my_func(x: i32, y: i32) {
	println!("{}", x+y);
}
```