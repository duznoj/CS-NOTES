Right after the Protective MBR, the very next LBA needs to store the Primary GPT Header.

The format for this header can be found in the UEFI spec at Section 5.3.2, along with values for any magic numbers

1. `signature`: is supposed to be the exact string "EFI PART", without any null-termination.
2. `revision`: shows what specification of GPT is being used, currently most standard is `1.0` which is written as `0x00010000`
3. `header_size`: is 92B
4. `header_crc32`: should be kept `0` when calculating the CRC32 value
5. `reserved`: needs to be set to 0
6. `my_lba`: is at which LBA is this GPT header living in
7. `alternate_lba`: is at which LBA the secondary GPT Header living in.
	- The secondary header lives at the last LBA of the disk, it is used in case the primary header gets corrupted type shi.
8. `first_usable_lba`: is the first LBA where we can store actual shit
	- = 1 (MBR) + 1 (GPT Header) + size of GPT in LBAs
	- It is conventional to use 128 entries, each of 128B, which totals to `128 x 128 = 16KiB` which is equivalent to 32 LBAs if LBA size = 512 
9. `last_usable_lba`: similar to the front side of the disk, there is supposed to be a secondary header and partition entries at the end of the disk, so the last usable LBA will be: `disk_lba - 1 - size of GPT in LBAs - 1`
	- one -1 for the GPT header, second -1 for 0 based indexing of LBAs.
10. `disk_guid`: A randomly generated valid GUID.
11. `partition_entry_lba`: At which LBA the partition entries start, at 0 is the MBR, at 1 is the GPT Header, so this can start at 2.
12. `number_partition_entries`: 128 idk why
13. `parition_entry_size`: spec says it can be any number of the form `128 x 2n` or 128B as well. We'll use 128B
14. `parition_entries_crc32`: calculate CRC32 of the partition entries array.


#### GUID(Globally Unique Identifier) or UUID (Universally Unique Identifier)

- The spec for this can be found at [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)
- GUID and UUIDs are same, Microsoft calls it GUID for some reason.
- It is like a unique 128-bit number within a context if generated well-randomly.
- Out of the 128 bits, only 122 are actually free to be random, other bits called the version and variant bits give meta data about how the UUID was generated.
- Eg: whether the UUID was generated via the current time from an epoch, or via random/pseudo-random generated numbers, in our case we are using the latter.
- So we'll basically fill all the bits with random values, but then set these version and variant bits particularly according to the standard.
- When generating a GUID using some other method like time and stuff, note that some parts/bytes of the 128 bit GUID are little endian while others are big endian, making GUID a "mixed endian" number/value/format, so be careful when filling it with properly generated values, we're using random values so we can just put anything anywhere.

IMPORTANT NOTEEE:
For some reason he chose variant 2, while variant 1 is commonly used, when testing the final product, use both variant 1 and 2

The version nibble will convert to a `0x4` and the variant nibble will convert to a `0xC` or a `0xD`, useful for visually validating.


#### CRC32 Stuff

We're stealing implementation of CRC32 from the [internet](https://www.w3.org/TR/png/#D-CRCAppendix).

- Basically there needs to be a "CRC Table" which has to be calculated only once.
- Then when calculating CRCs for any buffers this table will be used.
- So we'll make the table a part of the "disk context" struct and calculate it on initialization.
- The internet stolen implementations are `calculate_crc32_table`,  and `calculate_crc32`
