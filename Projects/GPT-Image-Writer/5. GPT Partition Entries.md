The format for a partition entry is in the UEFI spec Section 5.3.3

- `partitionTypeGUID`: is a special type of GUID used in the industry to signify which type of partition this is, it has specific values for different types like `unused_entry`, `EFI_System_Partition`, `Partition_Containinng_LEgacy_MBR`.
	- We can of course use/create our own "type" GUID, but those will be recognizable only by our own systems only if we write software supporting it. The EFI firmware won't.
- `UniquePartitionGUID`: is the GUID which will uniquely identify the partition.
	- Basically multiple partitions may have the same "Type GUID", but will have different "Unique Partition GUID"
- Rest of the fields are self-explanatory from the UEFI spec.
- We'll keep the partitions aligned at 1MiB boundaries for no reason.
- Since MBR + GPT Header + GPT Partition entries surely won't exceed the 1st 1MiB, we can safely start the ESP at the 1st 1MiB alignment.
- To get the start of the `data_partition` the `next_aligned_lba()` helper function finds the next 1MiB aligned boundary for you after the whole last used LBA of the ESP.
- The constants for  `Partition Type GUIDs` can be found on [wikipedia](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs)

NOTE:
- Do we need the "Basic Data Partition" by Microsoft? idk, test around later to confirm.
- There 128 GPT entries, each of 128B, which totals to 16KiB, this is evenly divisible by all 512B, 1024B, 2048B, 4096B, so no tension of padding any LBAs of this table with 0s, it will take different number of LBAs on different disks, but will always evenly and completely fill up the every LBA it uses, so no worries of padding/completing an LBA.
- But keep in mind that alignment of partitions will require you to skip some blocks
	- Eg: MBR + Primary GPT Header + GPT Table take up only 34 sectors.
	- Right after the GPTs should be the ESP, but since we're aligning Partitions at 1MiB boundaries, the ESP will start at sector 2048, which means sectors 34-2047 will be skipped and be unusable, to account for this the virtual disk image capacity must be increased. So basically assuming worst case scenario, for every time you align to a 1MiB boundary, assume an entire 1MiB was skipped to perform the alignment and increase the disk capacity by 1MiB each time to make up for it, otherwise LBAs in theory be calculated using alignments, but practically the disk won't be large enough to put shit according to that alignment.

#### Testing
To test whether the disk image you've created so far is valid or not, use:
```bash
sgdisk -[O][v][p] <disk-image-file>
```
It should report something along the lines of "No problems found".