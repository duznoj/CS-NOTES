
- Now that we have a valid GUID Partitioned disk.
- You can create more partitions by simply adding partition entries to the GPT Table, and making sure the `disk_capacity` variable is large enough to hold that partition in code, maybe make it such that a user is able to interact with the program to send commands and create/modify the partitions, which in the C code, modify the GPT Table. This is basically what tools like `fdisk` do.

- But that is boring shit, for now, we want to make the disk "bootable" and maybe somehow write some software program shit onto it which will use services offered by the UEFI firmware and start an OS or something. Similar to how the BIOS provided interrupts to print to the screen and stuff after booting.

- This is done by writing "UEFI Applications".

- A UEFI Application is just a binary software, but unlike in BIOS where we were able to boot the 1st sector of disk at `0x7C00` and raw-dog any assembly instructions from there.

- A UEFI Application resides inside the EFI System Partition (ESP), and for the UEFI firmware to interact with the ESP, the ESP is supposed to have `FAT32` as it's filesystem

- So now we implement the writing of the FAT32 Filesystem in the ESP.
<br>
<hr>

## FAT32 Filesystem
- Note that now the ESP is like it's own logical disk, so when the FAT32 spec tells you about the 1st LBA, or something, then actually it means the 1st LBA of the partition it resides in, not the entire disk, so you have to offset any LBA values in the FAT32 Headers and stuff by `esp_start_lba`.
- The spec kinda differentiates between the actual disk LBA, and the partitions LBA by calling the partition a "\[Logical] Volume".

### Boot Sector (BS) / BIOS Parameter Block (BPB) / Volume Boot Record (VBR)

- This is the 1st 512B of the partition/volume containing any FAT(12/16/32) Filesystem
- This is very much similar to the MBR, but what it does is, assuming the disk will be in a BIOS system
	- Make sure you jump to some valid intentional CPU instructions in the 1st 3 bytes
	- Then, from the 4th byte till 36th byte, have some FAT header which are common to all formats FAT(12/16/32)
	- Then from the 37th the header formats deviate, so implement the FAT32 one correctly
	- The FAT32 header is of total 90B, so bytes 91-510 is free for use for boot code, i.e, valid intentional CPU instructions, and you could make sure that the 1st 3 bytes mentioned above jump over to this address. But since we're not using this sector(BS/BPB/VBR) as the bootloader, we'll just zero this region out.
	- Then 511th and 512th byte have to be the boot signature for BIOS, i.e, 0x55, 0xAA
- A "FAT" data structure has an array of 32-bit entries for each "cluster".
- A "cluster" is a logical unit of data size used in filesystems, a cluster may or may not contain more than 1 sector. For our personal sanity we set the SectorsPerCluster to 1.

- The layout for a disk containing FAT32 filesystem looks something like

![[Disk offsetted  FAT32.png]]

In above diagram:
- "Entry Offset Sectors": is our MBR + GPT Header + GPTs
- "Reserved Sectors": is the sectors we put in the VBR.RsvdSecCnt, the "Reserved Sectors" INCLUDE the VBR.
- We are keeping two FATs, how much space should these take? In theory they may need lesser than this, but for our sanity, we'll start the data region of the ESP from a 1MiB alignment from the start of the ESP.
	- Therefore the reserved sectors + 2 * (sectors for 1 FAT) = sectors for 1MiB
	- Rearrange this to get sectors for 1 FAT = (sectors for 1MiB - reserved sectors)/2


### Why does the FAT32 Filesystem need the storage medium/disk/device to be 32MiB minimum?

- The simple answer is, they wanted the minimum number of "data clusters" in FAT32 to be 1 more than the max number of data clusters in FAT16.
- FAT16 has `65525` data clusters, and in least case you have at least 1 sector/cluster, which is = `65526 secotrs`.
- And UEFI and other specs recommend the data clusters begin at a 1MiB alignment, so for the Reserved space + FAT tables we leave at least 1MiB = `2048 sectors`
- Which brings the minimum total disk size to `66526 + 2048 = 67574 sectors` which is = `32MiB`, we use another 1MiB and make it 33MiB just to be safe.

### FAT Entries
- For FAT n systems, where n = 12/16/32, has the FAT Table of n-bit entries.
- In FAT32, each FAT entry is of 32-bits, but the top 4 bits are reserved, so only the last 28-bits are available for use
- Each entry maps to a cluster on the disk.
- Entries basically stores the next cluster number of where the next cluster of data for the current file/directory you're processing is.
	- So you read the entry number `x` from the table, so from the disk, you also read in cluster number `x` into RAM to process, suppose the value of entry `x` is `y`, so now you read entry number `y` from the table and cluster number `y` from the disk, and the value of entry number `y` will take you to the next cluster
	- And then that entry will show the next cluster number and so on.
- Kind of like how you process a Linked List, some special numbers like `0x0FFFFFFF` also called the End of Cluster Chain Indicator tell you when to stop.
- A clear diagram of this can be found [here](https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#Cluster_map).

#### Special Cluster values
1. The FAT entry for cluster 0 is always supposed to be the Media Type / FAT ID, `0x0FFFFFF00 |  Media_Type`
2. The FAT entry for cluster 1 is mandatorily the End of Cluster-Chain marker
3. The cluster 2 is ALWAYS implicitly the beginning of the root directory "/". Any data written inside it is like it exists INSIDE the root dir.
4. Note that even though we write FAT entries for clusters 0 and 1, they are just like metadata/markers, the clusters do not physically exist on disk, as seen in the FAT32 disk layout diagram above, right after the FATs, the data region for the FAT32 Partition starts at cluster 2.

#### Directory Items
- We are supposed to create the `/EFI` and `/EFI/BOOT` directories, and inside `/EFI/BOOT` we will write our EFI Applications.
- But how it works is, we write a "FAT32 Directory Item" entry at the beginning of cluster 2, which tells the FAT32 Driver where to look for the actual data of the `/EFI` directory.
- A directory item is a 32-Byte entry, it is basically a pointer to which physical cluster the `/EFI` directory resides, for example let's sat cluster x.
- Kind of like an index pointer, only containing metadata about how to access the data under this directory/filename.
- So basically when you `cd` into a directory and run `ls`, the FAT32 Driver only reads these small 32-byte items from disk to display you the file/directory names inside the current directory, and when you try to use any data INSIDE those items, it reads from the disk, from the cluster number mentioned in the FAT32 Item for that file/folder

![[FAT32 Item.png]]

- Similarly if you needed to create your own folders inside of `"/"`, you will write another directory item entry right after the "EFI" FAT32 directory item entry inside cluster 2 which will point to some cluster y containing the data inside the supposed /YOUR_FOLDER

- For the FAT32 Item Entries, we will be using the "short naming" version of items for ease. This is the 8 character item name and 3 character extension

- Since a directory item is only 32-Bytes, only 1 cluster is enough for the root dir, which the cluster chain in the FAT also reflects, so can start the data for "/EFI" directory at the very next cluster, i.e, cluster 3.

- Similarly inside the "/EFI" cluster we write a directory item entry for a "BOOT" directory which will be at the next cluster, i.e, cluster 4.

NOTE:
- Inside each directory, firstly there should be 2 FAT32 Directory items for the "." and ".." directories. Except the Root Directory, it should not have those 2 items.
- When you're inside "/EFI", or any other directory inside of root and writing the directory item for "..", i.e, root, you have to put the starting cluster number as 0 even though root starts at cluster 2, this is required by the spec for some reason.

To test if your FAT32 implementation is valid or not, run:
```bash
qemu-system-x86_64 -hda <your-hard-disk-image> -bios <uefi-firmware-file> -net none
```

Now in the UEFI Shell, there must be names for storage media like `Blk0`, `Blk1`.

Switch to the `FS0` disk using
```bash
FS0:
```

- Now you're in the root dir of our ESP.
- run `ls` or `dir` to see if the EFI directory exists
- `cd` into the EFI directory and check if the `"."`, `".."`, BOOT directories exists, `cd` into `BOOT` and check if `"."` and `".."` directories exist.
