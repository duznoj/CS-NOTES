From here,  with respect to git, files and directories are essentially the same thing, a `<filename>` mentioned can also be the name of a folder, unless explicitly mentioned otherwise

Files in your repo can be in 4 main states with respect to git:
1. Untracked
2. Unmodified
3. Modified
4. Staged


You can use the `git status` command to see in which state all files are in currently. To view the status of a particular file do a `git status <filename>`
###### Untracked
These are the files which git has no idea about and is not "tracking" them for changes etc, so these files will not be added in your next commit, so if you lose these files, they're gone forever.

Running a `git status`
```console
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
```

To start tracking a file you run
```bash
git add < <file-path> | <pattern> >
```

This puts the file/folder into what is called a "staging area".

Running a `git status` will look something like
```console
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README
```

What `git add` essentially does is that it prepares the **CURRENT** content file to be included in the next commit

Note that any changes made after the `git add` will not be included in the commit, and might be lost if you delete it.

Eg:
```bash
# Create a file and write some content in it
git add <filename> # Lets say this is v1 of the file

# Some changes to the file happen, lets say v2 of the file

git commit # Only changes upto v1 of the file will be included, v2 is still present, but only as a modification from v1

```

Now running a sit status will look like:
```console
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README
```

"Changes to be committed" is the tracked/staged version of the file when you `git added` it which is safe type shi, this content is kinda safe and can be recovered even if the file is now deleted.

Eg:
```bash
git add <file>    # saved w.r.t git
rm <file>         # deleted from the OS filesystem
git restore <file> # The file is restored via the .git folder magic, and content will be the same as the last git add to the file
```

"Changes not staged for commit" is the untracked version of the changes since the last `git add`, this content is kinda unsafe and content will be lost if such a file is modified or deleted

###### Unmodified
These are the files that have not been modified since the last commit, but are being tracked.
Nothing much to say about them

###### Modified
Modified since the last commit.
Is being tracked
Same shit after the "tracking" in above "Untracked" section works here.

###### Staged
The version of the file exactly when it is `git added`.
This puts the file in the "staging area", where things/changes in the repo are collected which are supposed to be tagged/included in the next commit.