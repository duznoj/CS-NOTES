
Now for some plumbing commands which you won't really use but are good to know to understand git internals.

Notice in the .git/objects folder, there is a structure similar to our hash.
If hash is `9b384df5acd912b1978454e377ccbfa8b18e489a`
The folder structure is:
`.git/objects/9b/384df5acd912b1978454e377ccbfa8b18e489a`

For each commit an individual commit hash, an object file is created which contains the entire commit history up to and including that commit. Therefore each commit needs a separate file. This might end up creating a lot of files, which causes [[unimplemented|inode  busting]] in an OS Filesystem.
To prevent inode busting git separates the first 2 characters of the hash are used as a directory.

Doing a `cat .git/objects/98/rest-of-the-hash` will print unreadable chars, this is because inside the file, the commit history is stored in a compressed format.

You can either uncompress it using external tools, or use
```bash
git cat-file -p <hash>
```

`git cat-file` is a plumbing command used to cat out the uncompressed versions of git object files.

There are different types of git objects, like commits, trees, blobs
use: 
```bash
git cat-file -t <hash>
```
to find out the type of object the hash is of.

A "tree" is like a directory.
A "blob" is like a file, and contains the end content of the file.

For each modification of a file between two commits, git compresses and saves both files separately, but if a file is unchanged between commits, git stores it only once and reuses the blob hash and shit

You can also observe that a commit also contains the hash of its previous(parent) commit.