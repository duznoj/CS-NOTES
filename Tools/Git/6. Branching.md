A "branch" allows you to keep track of different changes separately.

Eg:
If you have a project into a good state, and now want to add a feature, without disturbing the working state, you branch off and work on the feature, and then merge back in to the main branch when the feature is working.

But won't just using commits and going to previous commits work just fine in case anything with the new feature goes wrong?

Yes, kinda true. But, suppose you're working on two separate features, you leave one incomplete, are bored, and want to work on the other, now the unfinished 1st feature might fuck up the build process, not allowing you to test the new 2nd feature. So from a stable commit, you should branch off into 2 branches and work on the separate commits. This is also what is done in Open Source projects with lots of contributors, each contributor branches off from the main working root branch and merges when their work is finished.

###### What is a branch?
Does it make multiple copies of all the commits to keep track of them separately?

In short no, A git branch is simply a "named pointer" to the latest commit on the branch.

So depending upon which branch you are, the latest commit will be different, and recursively using the previous/parent commit of the current commit you can see where the branch leads to.


![[git branches.png]]

In the image above, we have commits `A`, `B`, `C`, `D`, `E`, and branches are `main` and `ip_parsing`

If you are on the main branch, the commits accessible to you are `A`, `B`, `C` and that is also what the commit history in `git log` will reflect

If you are on the main branch, the commits accessible to you are `A`, `B`, `D`, `E`.

Commits `C` and `E` are called `branch tips`.

Now there might've been other branches as well there is no restriction, and creating a branch is cheap as well since you don't clone the entire repo for each branch, you simply create a pointer, and update the pointer whenever a new commit is made.

In above diagram, for branches `main` and `ip_parsing`, commit `B` is the "most common ancestor", or might also be called the "merge base", since when merging the branches, the commits after `B` on both branches need to be handled, i.e, check whether `D`, `C` interfere with the work done by `C` or vice-versa.

```bash
git branch
```

lists out all the branches that exist in the repo, and it highlights the one you are currently on.

##### Creating a new branch
```bash
git branch <branch name>
# OR
git switch (-c|-C) <branch_name>
```

- `git branch` only creates a new branch, but doesn't switch to it
- `git switch` only switches to a branch
- The `-c` flag tells switch to create the branch if it doesn't exist AND also switch to it.
- The `-C` flag "force-creates" a branch and switches to it, i.e, if a branch of that name existed, it would reset it to point to the current commit.

`git checkout` also works in the same way as `git switch` but it's an older command, it is now recommended to use `git switch` for changing branches nowadays.

```bash
git log [--decorate=(short | full | no)]
```
will show complete `ref` name, a `ref` is just a pointer to a commit.
All branches are `refs` but all refs are not branches

In the `.git/refs/heads` directory are all the `heads`/`tips` of branches, each file is a branch name which contains the commit hash that the branch points to.

By default `git log` will only show logs of the current branch, to view all branches, you have to do a
```bash
git log --all
```