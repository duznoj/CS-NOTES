Once you're done with whatever changes/features/debugging you did on the "side branch", now you have to "merge" those changes into production.

Lets say you're repo is in a state like this:

![[GIT BEFORE MERGE.png]]

Now that you're done with the work on "other_branch", you merge it into the main branch, so the main branch has to have a commit after commits `B` and `C` to reflect the changes made by "other_branch"

This will look something like:
![[GIT AFTER MERGE.png]]

Where `F` is a commit on the main branch which represents all the changes made by `D` and `E`

`F` is a special commit called a "merge commit", it has two parents, `E` and `C`, this can be confirmed by plumbing the object files of commit `F`.

To make the merge commit, git does the following steps:
1. Find the "merge base" commit, or "best common ancestor" of the two branches. In above case `A`
2. Replays the changes from target branch starting from the merge base into a new commit
3. Replays the merging branches changes starting from the merge base into the same new commit
4. Gives the merge commit two parents, each is the branch tip of both branches before the merge
5. Makes the merge commit the branch tip of the target branch.

Now it might be possible the between commits `B`, `C` and commits `D`, `E`, commits from both branches tried to modify the same lines on same files. This is called a "merge conflict". This also needs to be handled, you either accept changes from one of the commits, or if accepting from both the commits, then put the content from different commits on different lines.
### How to merge?

First, switch to the branch you want to merge INTO, this is called the "target branch", in above example, that would be `main`, then run
```bash
git merge <branch_name> [-m <merge-commit-message>]
```

`<branch-name>` will be the name of the branch you want to bring in changes FROM, INTO the target branch.

Note that even after merging, you can still switch to and independently work on the `other_branch` and then later merge the newer changes into main, i.e, the branch still exists after merging.

In most cases, once you're done with a branch you want to delete it, so you don't accidentally switch to it type shi.

To delete a branch use the `-d` option: 
```bash
git branch -d <branch_name>
```

Now, the history of the branch still remains when you use `git log`, this is because of the hashes and parent hashes in every commit, but now you can't switch to the `other_branch` and do work.

### Fast Forward Merge

When the commit history looks something like:
![[fast forward merge.png]]


Now if you want to merge `other_branch` into `main`, you don't actually have to do the whole, play changes from `main`, play changes from `other_branch`, create a new commit, etc.

In short git simply makes the `main` branch point to the tip of `other_branch`.

This is only possible because no other events happened in the target branch after branching.

Or in short, the merge base of both branches is same as the tip of the target branch.

In this case, git DOES NOT create a merge commit, instead it just updates `main` to point to commit `E`

![[Fast forward merge after.png]]

